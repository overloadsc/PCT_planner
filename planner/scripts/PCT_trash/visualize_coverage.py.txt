#!/usr/bin/env python3
"""
覆盖路径规划可视化工具

使用 matplotlib 可视化:
- 可通行区域
- 候选路径
- 选中路径
- 覆盖情况
- 完整轨迹
"""
import sys
import argparse
import pickle
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.collections import LineCollection
import matplotlib.colors as mcolors

sys.path.append('../')
from coverage_planner import CoveragePathPlanner, create_coverage_planner
from config import Config


def visualize_coverage_result(planner: CoveragePathPlanner, 
                               trajectory: np.ndarray,
                               selected_paths,
                               coverage_rate: float,
                               save_path: str = None,
                               show: bool = True):
    """可视化覆盖路径规划结果
    
    Args:
        planner: 覆盖路径规划器实例
        trajectory: 完整轨迹
        selected_paths: 选中的路径列表
        coverage_rate: 覆盖率
        save_path: 保存图片路径（可选）
        show: 是否显示图片
    """
    fig, axes = plt.subplots(2, 2, figsize=(16, 14))
    fig.suptitle(f'Coverage Path Planning Result\n'
                 f'Selected Paths: {len(selected_paths)}, '
                 f'Coverage Rate: {coverage_rate:.1f}%', 
                 fontsize=14, fontweight='bold')
    
    # 获取覆盖地图
    coverage_map = planner.get_coverage_map()
    
    # 颜色映射
    cmap_coverage = mcolors.ListedColormap(['#333333', '#ff6b6b', '#51cf66'])
    
    # === 子图1: 可通行区域 ===
    ax1 = axes[0, 0]
    ax1.set_title('Traversable Region (cost < threshold)', fontsize=12)
    
    # 显示代价图
    trav_display = np.where(planner.trav_map < planner.traversable_threshold, 
                            planner.trav_map, np.nan)
    im1 = ax1.imshow(trav_display, cmap='viridis', origin='lower', 
                     aspect='equal', vmin=0, vmax=planner.traversable_threshold)
    plt.colorbar(im1, ax=ax1, label='Traversability Cost')
    ax1.set_xlabel('Column (grid)')
    ax1.set_ylabel('Row (grid)')
    
    # === 子图2: 覆盖情况 ===
    ax2 = axes[0, 1]
    ax2.set_title('Coverage Map (Green=Covered, Red=Uncovered)', fontsize=12)
    
    im2 = ax2.imshow(coverage_map, cmap=cmap_coverage, origin='lower', 
                     aspect='equal', vmin=0, vmax=2)
    cbar2 = plt.colorbar(im2, ax=ax2, ticks=[0, 1, 2])
    cbar2.ax.set_yticklabels(['Obstacle', 'Uncovered', 'Covered'])
    ax2.set_xlabel('Column (grid)')
    ax2.set_ylabel('Row (grid)')
    
    # === 子图3: 选中的路径（世界坐标） ===
    ax3 = axes[1, 0]
    ax3.set_title(f'Selected Paths ({len(selected_paths)} paths)', fontsize=12)
    
    # 绘制可通行区域边界
    rows = [c[0] for c in planner.traversable_cells]
    cols = [c[1] for c in planner.traversable_cells]
    world_x = [(c - planner.offset[0]) * planner.resolution + planner.center[0] for c in cols]
    world_y = [(r - planner.offset[1]) * planner.resolution + planner.center[1] for r in rows]
    ax3.scatter(world_x, world_y, c='lightgray', s=1, alpha=0.3, label='Traversable')
    
    # 绘制各路径
    colors = plt.cm.rainbow(np.linspace(0, 1, len(selected_paths)))
    for i, path in enumerate(selected_paths):
        traj = path.trajectory
        ax3.plot(traj[:, 0], traj[:, 1], '-', color=colors[i], linewidth=2, 
                label=f'Path {path.path_id}')
        ax3.plot(traj[0, 0], traj[0, 1], 'go', markersize=8)  # 起点
        ax3.plot(traj[-1, 0], traj[-1, 1], 'rs', markersize=8)  # 终点
    
    ax3.set_xlabel('X (m)')
    ax3.set_ylabel('Y (m)')
    ax3.set_aspect('equal')
    ax3.legend(loc='upper right', fontsize=8, ncol=2)
    ax3.grid(True, alpha=0.3)
    
    # === 子图4: 完整轨迹 ===
    ax4 = axes[1, 1]
    ax4.set_title(f'Complete Trajectory ({len(trajectory)} points)', fontsize=12)
    
    # 背景：可通行区域
    ax4.scatter(world_x, world_y, c='lightgray', s=1, alpha=0.3)
    
    # 绘制完整轨迹（用颜色表示顺序）
    if len(trajectory) > 1:
        points = trajectory[:, :2].reshape(-1, 1, 2)
        segments = np.concatenate([points[:-1], points[1:]], axis=1)
        
        # 颜色从蓝到红表示时间顺序
        norm = plt.Normalize(0, len(segments))
        lc = LineCollection(segments, cmap='coolwarm', norm=norm, linewidth=2)
        lc.set_array(np.arange(len(segments)))
        ax4.add_collection(lc)
        plt.colorbar(lc, ax=ax4, label='Trajectory Progress')
    
    # 标记起点和终点
    if len(trajectory) > 0:
        ax4.plot(trajectory[0, 0], trajectory[0, 1], 'g^', markersize=15, 
                label='Start', markeredgecolor='black', markeredgewidth=2)
        ax4.plot(trajectory[-1, 0], trajectory[-1, 1], 'rv', markersize=15, 
                label='End', markeredgecolor='black', markeredgewidth=2)
    
    ax4.set_xlabel('X (m)')
    ax4.set_ylabel('Y (m)')
    ax4.set_aspect('equal')
    ax4.legend(loc='upper right')
    ax4.grid(True, alpha=0.3)
    
    # 设置坐标范围
    if len(trajectory) > 0:
        margin = 5
        x_min, x_max = trajectory[:, 0].min() - margin, trajectory[:, 0].max() + margin
        y_min, y_max = trajectory[:, 1].min() - margin, trajectory[:, 1].max() + margin
        ax4.set_xlim(x_min, x_max)
        ax4.set_ylim(y_min, y_max)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"图片已保存到: {save_path}")
    
    if show:
        plt.show()
    
    return fig


def visualize_candidate_paths(planner: CoveragePathPlanner, 
                               save_path: str = None,
                               show: bool = True):
    """可视化所有候选路径
    
    Args:
        planner: 覆盖路径规划器实例
        save_path: 保存图片路径（可选）
        show: 是否显示图片
    """
    fig, ax = plt.subplots(figsize=(12, 10))
    ax.set_title(f'Candidate Paths ({len(planner.candidate_paths)} paths)', fontsize=14)
    
    # 绘制可通行区域
    rows = [c[0] for c in planner.traversable_cells]
    cols = [c[1] for c in planner.traversable_cells]
    world_x = [(c - planner.offset[0]) * planner.resolution + planner.center[0] for c in cols]
    world_y = [(r - planner.offset[1]) * planner.resolution + planner.center[1] for r in rows]
    ax.scatter(world_x, world_y, c='lightgray', s=1, alpha=0.3)
    
    # 绘制各候选路径
    for path in planner.candidate_paths:
        traj = path.trajectory
        ax.plot(traj[:, 0], traj[:, 1], '-', alpha=0.5, linewidth=1)
    
    ax.set_xlabel('X (m)')
    ax.set_ylabel('Y (m)')
    ax.set_aspect('equal')
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"图片已保存到: {save_path}")
    
    if show:
        plt.show()
    
    return fig


def visualize_coverage_statistics(planner: CoveragePathPlanner,
                                   selected_paths,
                                   save_path: str = None,
                                   show: bool = True):
    """可视化覆盖统计信息
    
    Args:
        planner: 覆盖路径规划器实例
        selected_paths: 选中的路径列表
        save_path: 保存图片路径（可选）
        show: 是否显示图片
    """
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))
    
    # === 统计1: 每条路径覆盖的网格数 ===
    ax1 = axes[0]
    path_ids = [p.path_id for p in selected_paths]
    coverage_counts = [len(p.covered_cells) for p in selected_paths]
    
    bars = ax1.bar(range(len(selected_paths)), coverage_counts, color='steelblue')
    ax1.set_xticks(range(len(selected_paths)))
    ax1.set_xticklabels([f'P{pid}' for pid in path_ids], rotation=45)
    ax1.set_xlabel('Path ID')
    ax1.set_ylabel('Covered Cells')
    ax1.set_title('Coverage per Selected Path')
    
    # 在柱状图上显示数值
    for bar, count in zip(bars, coverage_counts):
        ax1.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 50, 
                str(count), ha='center', va='bottom', fontsize=9)
    
    # === 统计2: 累积覆盖率 ===
    ax2 = axes[1]
    
    total_cells = len(planner.traversable_cells)
    cumulative_covered = set()
    cumulative_rates = []
    
    for path in selected_paths:
        cumulative_covered |= path.covered_cells
        rate = len(cumulative_covered) / total_cells * 100
        cumulative_rates.append(rate)
    
    ax2.plot(range(1, len(selected_paths) + 1), cumulative_rates, 'b-o', linewidth=2)
    ax2.axhline(y=100, color='r', linestyle='--', alpha=0.5, label='100%')
    ax2.fill_between(range(1, len(selected_paths) + 1), cumulative_rates, alpha=0.3)
    ax2.set_xlabel('Number of Paths')
    ax2.set_ylabel('Cumulative Coverage Rate (%)')
    ax2.set_title('Cumulative Coverage Rate')
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    ax2.set_ylim(0, 105)
    
    # === 统计3: 路径长度分布 ===
    ax3 = axes[2]
    
    path_lengths = []
    for path in selected_paths:
        traj = path.trajectory
        length = np.sum(np.linalg.norm(np.diff(traj, axis=0), axis=1))
        path_lengths.append(length)
    
    bars = ax3.bar(range(len(selected_paths)), path_lengths, color='coral')
    ax3.set_xticks(range(len(selected_paths)))
    ax3.set_xticklabels([f'P{pid}' for pid in path_ids], rotation=45)
    ax3.set_xlabel('Path ID')
    ax3.set_ylabel('Path Length (m)')
    ax3.set_title('Path Length per Selected Path')
    
    # 显示总长度
    total_length = sum(path_lengths)
    ax3.axhline(y=np.mean(path_lengths), color='g', linestyle='--', alpha=0.5, 
               label=f'Avg: {np.mean(path_lengths):.1f}m')
    ax3.legend()
    ax3.text(0.02, 0.98, f'Total: {total_length:.1f}m', transform=ax3.transAxes,
            verticalalignment='top', fontsize=10, 
            bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"图片已保存到: {save_path}")
    
    if show:
        plt.show()
    
    return fig


def main():
    parser = argparse.ArgumentParser(description='覆盖路径规划可视化工具')
    parser.add_argument('--scene', type=str, default='Plaza', 
                        help='场景名称: Spiral, Building, Plaza')
    parser.add_argument('--coverage_radius', type=float, default=2.0,
                        help='覆盖半径（米）')
    parser.add_argument('--waypoint_spacing', type=float, default=8.0,
                        help='路点间距（米）')
    parser.add_argument('--connection_mode', type=str, default='mixed',
                        choices=['nearest', 'sweep_h', 'sweep_v', 'mixed'],
                        help='起点终点连接模式')
    parser.add_argument('--save_dir', type=str, default='/tmp',
                        help='图片保存目录')
    parser.add_argument('--no_show', action='store_true',
                        help='不显示图片')
    parser.add_argument('--load', type=str, default=None,
                        help='从pickle文件加载结果')
    args = parser.parse_args()
    
    show = not args.no_show
    
    if args.load:
        # 从文件加载
        print(f"从文件加载: {args.load}")
        with open(args.load, 'rb') as f:
            result = pickle.load(f)
        
        trajectory = result['trajectory']
        selected_paths_data = result['selected_paths']
        coverage_rate = result['coverage_rate']
        params = result.get('params', {})
        
        scene = params.get('scene', args.scene)
        coverage_radius = params.get('coverage_radius', args.coverage_radius)
        
        # 重新创建规划器（用于可视化）
        planner = create_coverage_planner(scene=scene, coverage_radius=coverage_radius)
        
        # 手动设置选中的路径
        from coverage_planner import PathInfo
        selected_paths = []
        for p_data in selected_paths_data:
            path_info = PathInfo(
                path_id=p_data['path_id'],
                start_pos=p_data['start_pos'],
                end_pos=p_data['end_pos'],
                trajectory=p_data['trajectory'],
                covered_cells=planner._compute_path_coverage(p_data['trajectory'])
            )
            selected_paths.append(path_info)
        planner.selected_paths = selected_paths
        
    else:
        # 运行规划
        print(f"运行覆盖路径规划...")
        planner = create_coverage_planner(
            scene=args.scene,
            coverage_radius=args.coverage_radius
        )
        
        trajectory, selected_paths, coverage_rate = planner.run_auto(
            waypoint_spacing=args.waypoint_spacing,
            connection_mode=args.connection_mode
        )
    
    # 可视化
    print("\n生成可视化...")
    
    # 主结果图
    visualize_coverage_result(
        planner, trajectory, selected_paths, coverage_rate,
        save_path=f"{args.save_dir}/coverage_result_{args.scene}.png",
        show=show
    )
    
    # 统计图
    if selected_paths:
        visualize_coverage_statistics(
            planner, selected_paths,
            save_path=f"{args.save_dir}/coverage_stats_{args.scene}.png",
            show=show
        )
    
    print("\n可视化完成!")


if __name__ == '__main__':
    main()

